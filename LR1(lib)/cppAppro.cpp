#include <iostream>
#include <cmath>
#include <iomanip>
#include "hlib.h"
#include "hlib_osnfun.h"
using namespace std;

//определение для функции линейной аппроксимации
void Lineral(double x[], double y[], int n, double &Rl)
{
	//объявление переменных
	double A, B, C, D, k, b, E, se, F, sf, sfk;
	cout << "\nВЫЧИСЛЕНИЯ ДЛЯ ЛИНЕЙНОЙ АППРОКСИМАЦИИ" << endl;
	//вычисление суммы координат
	B = Suma(x, n);
	C = Suma(y, n);
	//вычисление скалярного произведения векторов
	A = Proiz(x, y, n);
	//сумма квадратов координат
	D = SumKvad(x, n);
	cout << "\nСумма координат первого вектора = " << B;
	cout << "\nСумма координат второго вектора = " << C;
	cout << "\nСкалярное произведение векторов = " << A;
	cout << "\nСумма квадратов координат первого вектора = " << D;
	//считаем коэффициенты
	k = (n*A - B*C) / (n*D - pow(B, 2));
	b = (C - k*B) / n;
	cout << "\nКоэффициент k для линейной аппроксимации = " << k;
	cout << "\nКоэффициент b для линейной аппроксимации = " << b << endl;
	cout << "\nТогда уравнение будет иметь вид" << endl;
	cout << "\ny = " << k << "*x + " << b << endl;
	Rl = 0;
	//считаем числитель
	se = 0;
	sf = 0;
	sfk = 0;
	for (int i = 0; i < n; i++)
	{
		E = y[i] - (k*x[i] + b);
		se = se + pow(E, 2);
	}
	//считаем слагаемые знаменателя
	for (int i = 0; i < n; i++)
	{
		F = k*x[i] + b;
		sf = sf + pow(F, 2);
		sfk = sfk + F;
	}
	sfk = pow(sfk, 2);
	//считаем суммарную квадратичную погрешность
	Rl = 1 - (se / (sf - sfk / n));
	//выводим все результаты
	cout.setf(ios::fixed);
	cout.setf(ios::showpoint);
	cout.precision(10);
	cout << "\nСуммарная квадратичная погрешность R для линейной аппроксимации = " << Rl;
	cout << endl;
}
//определение для функции степенной аппроксимации
void Stepen(double x[], double y[], int n, double &Rs)
{
	//объявление переменных
	double H, J, G, K, bs, ks, L, sl, M, sm, smk;
	cout << "\nВЫЧИСЛЕНИЯ ДЛЯ СТЕПЕННОЙ АППРОКСИМАЦИИ" << endl;
	//вычисление суммы координат для степенной аппроксимации
	H = SumaLN(x, n);
	J = SumaLN(y, n);
	//вычисление скалярного произведения векторов для степенной аппроксимации
	G = ProizLN(x, y, n);
	//сумма квадратов координат для степенной аппроксимации
	K = SumKvadLN(x, n);
	cout << "\nСумма координат первго вектора = " << H;
	cout << "\nСумма координат второго вектора = " << J;
	cout << "\nСкалярное произведение векторов для степенной аппроксимации = " << G;
	cout << "\nСумма квадратов координат первого вектора для степенной аппроксимации = " << K;
	cout.setf(ios::fixed);
	cout.precision(4);
	//считаем коэффициенты для степенной аппроксимации
	bs = (n*G - H*J) / (n*K - pow(H, 2));
	ks = exp((J - bs*H) / n);
	cout << "\nКоэффициент b для степенной аппроксимации = " << bs;
	cout << "\nКоэффициент k для степенной аппроксимации = " << ks << endl;
	cout << "\nТогда уравнение будет иметь вид" << endl;
	cout << "\ny = " << ks << "*x^" << bs << endl;
	Rs = 0;
	//считаем числитель для суммарной квадратичной погрешности степенной аппроксимации
	sl = 0;
	sm = 0;
	smk = 0;
	for (int i = 0; i < n; i++)
	{
		L = y[i] - (ks*pow(x[i], bs));
		sl = sl + pow(L, 2);
	}
	//считаем слагаемые знаменателя для суммарной квадратичной погрешности степенной аппроксимации
	for (int i = 0; i < n; i++)
	{
		M = ks*pow(x[i], bs);
		sm = sm + pow(M, 2);
		smk = smk + M;
	}
	smk = pow(smk, 2);
	//считаем суммарную квадратичную погрешность для степенной аппроксимации
	Rs = 1 - (sl / (sm - smk / n));
	//выводим результаты
	cout << "\nСуммарная квадратичная погрешность для степенной аппроксимации R = " << Rs;
	cout.unsetf(ios::fixed);
	cout << endl;
}
//определение для функции квадратичной аппроксимации
void Kvad(double x[], double y[], int n, double &Rk)
{
	//объявление переменных
	double A, B, C, D, F, F1, F2, a, b, c, E, se, sg, sgk;
	cout << "\nВЫЧИСЛЕНИЯ ДЛЯ КВАДРАТИЧНОЙ АППРОКСИМАЦИИ" << endl;
	cout.setf(ios::fixed);
	cout.precision(8);
	//вычисление суммы координат вектора 
	B = Suma(x, n);
	C = Suma(y, n);
	//вычисление скалярного произведения векторов 
	A = Proiz(x, y, n);
	//сумма квадратов координат 
	D = ProizKvad(x, y, n);
	F = SumKvad(x, n);
	F1 = SumKub(x, n);
	F2 = SumTetr(x, n);
	cout << "\nСумма координат первого вектора = " << B;
	cout << "\nСумма координат второго вектора = " << C;
	cout << "\nСкалярное произведение векторов = " << A;
	cout << "\nСкалярное произведение квадрата первого вектора на второй вектор = " << D;
	cout << "\nСумма квадратов координат первого вектора = " << F;
	cout << "\nСумма кубов координат первого вектора = " << F1;
	cout << "\nСумма четвертой степени координат первого вектора = " << F2;
	cout << "\nТогда система уравнений примет вид:\n" << endl;
	cout << F2 << "a + " << F1 << "b + " << F << "c =" << D << endl;
	cout << F1 << "a + " << F << "b + " << B << "c =" << A << endl;
	cout << F << "a + " << B << "b + " << n << "c =" << C << endl;
	cout << "\nПосчитайте коэффициенты a, b, c с помощью MATLAB и введите\n";
	cout << "\nВведите коэффициент a ";
	cin >> a;
	cout << "\nВведите коэффициент b ";
	cin >> b;
	cout << "\nВведите коэффициент c ";
	cin >> c;
	cout.setf(ios::fixed);
	cout.precision(4);
	cout << "\nТогда уравнение будет иметь вид" << endl;
	cout.setf(ios::fixed);
	cout.precision(1);
	cout << "\ny = " << a << "x^2 + " << b << "x + " << c << endl;
	cout << "\na = " << a << "   " << "b = " << b << "   " << "c =" << c << endl;
	Rk = 0;
	//считаем числитель для суммарной квадратичной погрешности
	se = 0;
	sg = 0;
	sgk = 0;
	for (int i = 0; i < n; i++)
	{
		E = y[i] - (a*pow(x[i], 2.0) + b*x[i] + c);
		se = se + pow(E, 2);
	}
	//считаем слагаемые знаменателя для суммарной квадратичной погрешности 
	for (int i = 0; i < n; i++)
	{
		sg = sg + pow((a*pow(x[i], 2) + b*x[i] + c), 2);
		sgk = sgk + (a*pow(x[i], 2) + b*x[i] + c);
	}
	sgk = pow(sgk, 2);
	//считаем суммарную квадратичную погрешность 
	Rk = 1 - (se / (sg - sgk / n));
	//выводим результаты
	cout.setf(ios::fixed);
	cout.precision(8);
	cout << "\nСуммарная квадратичная погрешность для квадратичной аппроксимации R = " << Rk;
	cout.unsetf(ios::fixed);
	cout << endl;
}